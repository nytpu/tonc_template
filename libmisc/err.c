// VERSION: 1.0.2
/* This file contains functions similar to *BSD's err and warn family of
 * functions, but implemented portably.  Also includes the {get,set}progname
 * extensions to stdlib.h.
 * See <https://www.freebsd.org/cgi/man.cgi?query=err&sektion=3> for more
 * information on these functions.
 * It should be noted that the eval parameter was removed from the err family
 * of functions, and they all exit with EXIT_FAILURE for portablilty reasons.
 *
 *
 * Copyright (c) 2021 nytpu <alex [at] nytpu.com>
 * SPDX-License-Identifier: BSL-1.0
 * The orginal source for this file is available at <https://git.sr.ht/~nytpu/libmisc>.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "err.h"

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *progname = "call setprogname()";
static FILE *err_file;
static void (*err_exit_func)(void);

const char *
getprogname(void)
{
	return progname;
}

void
setprogname(const char *name)
{
	const char *p = strrchr(name, '/');
	if (p != NULL) progname = p + 1;
	else progname = name;
}

void
err_set_file(void *file)
{
	if (file) err_file = file;
	else err_file = stderr;
}

void
err_set_exit(void (*exit_func)(void))
{
	err_exit_func = exit_func;
}

void
err(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	verrc(errno, fmt, ap);
	va_end(ap);
}

void
errc(int code, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	verrc(code, fmt, ap);
	va_end(ap);
}

void
verr(const char *fmt, va_list ap)
{
	verrc(errno, fmt, ap);
}

void
verrc(int code, const char *fmt, va_list ap)
{
	if (err_file == NULL) err_set_file(NULL);
	fprintf(err_file, "%s: ", getprogname());
	if (fmt != NULL) {
		vfprintf(err_file, fmt, ap);
		fprintf(err_file, ": ");
	}
	fprintf(err_file, "%s\n", strerror(code));
	if (err_exit_func) err_exit_func();
	exit(EXIT_FAILURE);
}

void
warn(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vwarnc(errno, fmt, ap);
	va_end(ap);
}

void
warnc(int code, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vwarnc(code, fmt, ap);
	va_end(ap);
}

void
vwarn(const char *fmt, va_list ap)
{
	vwarnc(errno, fmt, ap);
}

void
vwarnc(int code, const char *fmt, va_list ap)
{
	if (err_file == NULL) err_set_file(NULL);
	fprintf(err_file, "%s: ", getprogname());
	if (fmt != NULL) {
		vfprintf(err_file, fmt, ap);
		fprintf(err_file, ": ");
	}
	fprintf(err_file, "%s\n", strerror(code));
}

void
errx(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	verrx(fmt, ap);
	va_end(ap);
}

void
verrx(const char *fmt, va_list ap)
{
	if (err_file == NULL) err_set_file(NULL);
	fprintf(err_file, "%s: ", getprogname());
	if (fmt != NULL) {
		vfprintf(err_file, fmt, ap);
	}
	fprintf(err_file, "\n");
	if (err_exit_func) err_exit_func();
	exit(EXIT_FAILURE);
}

void
warnx(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);
}

void
vwarnx(const char *fmt, va_list ap)
{
	if (err_file == NULL) err_set_file(NULL);
	fprintf(err_file, "%s: ", getprogname());
	if (fmt != NULL) {
		vfprintf(err_file, fmt, ap);
	}
	fprintf(err_file, "\n");
}
